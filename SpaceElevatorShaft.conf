
# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: Space Elevator (Shaft)

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual
    button:
        class: ManualButtonUnit
        select: manual
    forcefield:
        class: ForceFieldUnit
        select: manual
    screen:
        class: ScreenUnit
        select: manual

handlers:
    unit:
        start:
            lua: |
                Positions = {254.5,272.65,288.75,305,321.25,337.5,354,370}
                PositionNames = {"Public Area", "Ingots & Alloys", "Parts Manufacture", "Mechanism Manufacture","Floor 4 WIP","Floor 5 WIP", "Floor 6 WIP", "Floor 7 WIP"}
                
                
                --StartPosition = vec3({80923953.767545,54644237.943587,-931401.97570413})
                StartPosition = vec3(core.getConstructWorldPos())
                system.print("Start Pos: " .. StartPosition.x .. "," .. StartPosition.y .. "," .. StartPosition.z)
                --Forward = vec3({0,0,-1})
                Forward = vec3(core.getConstructWorldOrientationForward())
                system.print("Forward Direction: " .. Forward.x .. "," .. Forward.y .. "," .. Forward.z)
                
                
                
                
                -- Find the nearest Position and set our index to that
                local minDistance = -1
                local closestPos = nil
                local alt = core.getAltitude()
                for k,v in pairs(Positions) do
                    local dist = math.abs(alt-v)
                    if minDistance == -1 or dist < minDistance then
                        closestPos = k
                        minDistance = dist
                    end
                end
            
                SelectedIndex = closestPos
                DisplayIndex = SelectedIndex
                
                StartVertical = -vec3(core.getWorldVertical())
                
                MaxSpeed = 20 --export: in m/s, max speed up or down
                CenteringForce = 30 --export: Scalar for centering force
                CenteringDampening = 250 --export: Dampening factor for centering force
                
                
                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(0)
                
                -- For testing purposes
                if antigrav then
                    antigrav.show()
                end
                
                function Kinematics()

                    local Kinematic = {} -- just a namespace
                    local C = 30000000 / 3600
                    local C2 = C * C
                    local ITERATIONS = 100 -- iterations over engine "warm-up" period
                    local function lorentz(v)
                        return 1 / math.sqrt(1 - v * v / C2)
                    end

                    function Kinematic.computeAccelerationTime(initial, acceleration, final)
                        -- The low speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)
                        local k1 = C * math.asin(initial / C)
                        return (C * math.asin(final / C) - k1) / acceleration
                    end

                    function Kinematic.computeDistanceAndTime(initial, final, restMass, thrust, t50, brakeThrust)

                        t50 = t50 or 0
                        brakeThrust = brakeThrust or 0 -- usually zero when accelerating
                        local speedUp = initial <= final
                        local a0 = thrust * (speedUp and 1 or -1) / restMass
                        local b0 = -brakeThrust / restMass
                        local totA = a0 + b0
                        if speedUp and totA <= 0 or not speedUp and totA >= 0 then
                            return -1, -1 -- no solution
                        end
                        local distanceToMax, timeToMax = 0, 0

                        if a0 ~= 0 and t50 > 0 then

                            local k1 = math.asin(initial / C)
                            local c1 = math.pi * (a0 / 2 + b0)
                            local c2 = a0 * t50
                            local c3 = C * math.pi
                            local v = function(t)
                                local w = (c1 * t - c2 * math.sin(math.pi * t / 2 / t50) + c3 * k1) / c3
                                local tan = math.tan(w)
                                return C * tan / math.sqrt(tan * tan + 1)
                            end
                            local speedchk = speedUp and function(s)
                                return s >= final
                            end or function(s)
                                return s <= final
                            end
                            timeToMax = 2 * t50
                            if speedchk(v(timeToMax)) then
                                local lasttime = 0
                                while math.abs(timeToMax - lasttime) > 0.5 do
                                    local t = (timeToMax + lasttime) / 2
                                    if speedchk(v(t)) then
                                        timeToMax = t
                                    else
                                        lasttime = t
                                    end
                                end
                            end
                            -- There is no closed form solution for distance in this case.
                            -- Numerically integrate for time t=0 to t=2*T50 (or less)
                            local lastv = initial
                            local tinc = timeToMax / ITERATIONS
                            for step = 1, ITERATIONS do
                                local speed = v(step * tinc)
                                distanceToMax = distanceToMax + (speed + lastv) * tinc / 2
                                lastv = speed
                            end
                            if timeToMax < 2 * t50 then
                                return distanceToMax, timeToMax
                            end
                            initial = lastv
                        end

                        local k1 = C * math.asin(initial / C)
                        local time = (C * math.asin(final / C) - k1) / totA
                        local k2 = C2 * math.cos(k1 / C) / totA
                        local distance = k2 - C2 * math.cos((totA * time + k1) / C) / totA
                        return distance + distanceToMax, time + timeToMax
                    end

                    function Kinematic.computeTravelTime(initial, acceleration, distance)
                        -- The low speed limit of following is: t=(sqrt(2ad+v^2)-v)/a
                        -- (from: d=vt+at^2/2)
                        if distance == 0 then
                            return 0
                        end
                        if acceleration > 0 then
                            local k1 = C * math.asin(initial / C)
                            local k2 = C2 * math.cos(k1 / C) / acceleration
                            return (C * math.acos(acceleration * (k2 - distance) / C2) - k1) / acceleration
                        end
                        assert(initial > 0, 'Acceleration and initial speed are both zero.')
                        return distance / initial
                    end

                    function Kinematic.lorentz(v)
                        return lorentz(v)
                    end
                    return Kinematic
                end
                
                
                function getPitch(gravityDirection, forward, right)
                    local horizontalForward = gravityDirection:cross(right):normalize_inplace() -- Cross forward?
                    local pitch = math.acos(utils.clamp(horizontalForward:dot(-forward), -1, 1)) * constants.rad2deg -- acos?
                    if horizontalForward:cross(-forward):dot(right) < 0 then pitch = -pitch end -- Cross right dot forward?
                    return pitch
                end
                
                function NextPosition()
                    if button_3 then
                        NextDisplayPosition()
                    else
                        ChangingPositions = true
                        SelectedIndex = SelectedIndex + 1
                        if SelectedIndex > #Positions then
                            SelectedIndex = #Positions
                        end
                        if forcefield_1 then -- Gate
                            forcefield_1.activate()
                        end
                        local altitude = core.getAltitude()
                        StartDiff = Positions[SelectedIndex]-altitude
                        InitialDirection = utils.sign(StartDiff)
                        desiredBaseAltitude = Positions[SelectedIndex]
                        AntigravTargetAltitude = desiredBaseAltitude
                    end
                end
                
                function PrevPosition()
                    if button_3 then
                        PrevDisplayPosition()
                    else
                        ChangingPositions = true
                        SelectedIndex = SelectedIndex - 1
                        if SelectedIndex < 1 then
                            SelectedIndex = 1
                        end
                        if forcefield_1 then -- Gate
                            forcefield_1.activate()
                        end
                        local altitude = core.getAltitude()
                        StartDiff = Positions[SelectedIndex]-altitude
                        InitialDirection = utils.sign(StartDiff)
                        desiredBaseAltitude = Positions[SelectedIndex]
                        AntigravTargetAltitude = desiredBaseAltitude
                    end
                end
                
                function ExecuteDisplayPosition()
                    SelectedIndex = DisplayIndex
                    ChangingPositions = true
                    if forcefield_1 then -- Gate
                        forcefield_1.activate()
                    end
                    local altitude = core.getAltitude()
                    StartDiff = Positions[SelectedIndex]-altitude
                    InitialDirection = utils.sign(StartDiff)
                    desiredBaseAltitude = Positions[SelectedIndex]
                    AntigravTargetAltitude = desiredBaseAltitude
                end
                
                function NextDisplayPosition()
                    DisplayIndex = DisplayIndex + 1
                    if DisplayIndex > #Positions then
                        DisplayIndex = #Positions
                    end
                end
                
                function PrevDisplayPosition()
                    DisplayIndex = DisplayIndex - 1
                    if DisplayIndex < 1 then
                        DisplayIndex = 1
                    end
                end
                
                function getDistanceDisplayString(distance)
                    local su = distance > 100000
                    local result = ""
                    if su then
                        -- Convert to SU
                        result = utils.round(distance/1000/200,1) .. " SU"
                    elseif distance < 1000 then
                        result = utils.round(distance,1) .. " M"
                    else
                        -- Convert to KM
                        result = utils.round(distance/1000,1) .. " KM"
                    end

                    return result
                end
                
                ChangingPositions = false
                InitialDirection = 0
                Kinematic = Kinematics()
                
                LastOn = false
                
                LastTime = system.getTime()
                unit.hide()
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()
                
    screen_1:
        mouseDown(x,y):
            lua: |
                local convertedX = x * 1024
                local convertedY = y * 612
                local ButtonPadding = 4
                local ButtonX = ButtonPadding
                local ButtonY = 105
                local ButtonWidth = 1024 - ButtonPadding
                local ButtonHeight = 35
                
                for k,v in pairs(Positions) do
                    local buttonX = ButtonX
                    local buttonY = ButtonY + (#Positions-k)*(ButtonHeight+ButtonPadding)
                    
                    local selected = (k == SelectedIndex)
                    if not selected then
                        if convertedX > buttonX and convertedX < buttonX + ButtonWidth and convertedY > buttonY and convertedY < buttonY + ButtonHeight then
                            DisplayIndex = k
                        end
                    end
                end
                
                if convertedY < 95 and SelectedIndex ~= DisplayIndex then
                    ExecuteDisplayPosition()
                end
        
    system:
        start:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 10 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                if worldVertical:len() < 0.1 then
                    worldVertical = StartVertical -- Use our stored one if in space
                end
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)
                
                local currentPitchDeg = getPitch(worldVertical, constructForward, constructRight)
                local currentPitchDegAbs = math.abs(currentPitchDeg)
                local currentPitchDegSign = utils.sign(currentPitchDeg)
                
                local currentYawDeg = constructRight:dot(Forward)*180
                local currentYawDegAbs = math.abs(currentYawDeg)
                local currentYawDegSign = utils.sign(currentYawDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp
                                                
                local vSpeed = constructVelocity:project_on(worldVertical):len()
                local vSpeedSigned = vSpeed * -utils.sign(constructVelocity:dot(worldVertical))
                local fakeBrake = false
                
                local time = system.getTime()
                local deltaTime = time-LastTime
                LastTime = time

                local accel = vec3(core.getWorldAcceleration())
                --system.print((accel:len()*-utils.sign(accel:dot(worldVertical))))
                local alt = core.getAltitude() + vSpeedSigned*deltaTime + 2*(accel:len()*utils.sign(accel:dot(worldVertical)))*deltaTime*deltaTime
                

                local maxBrake = json.decode(unit.getData()).maxBrake
                if maxBrake ~= nil then
                    LastMaxBrake = maxBrake
                end   
                
                local brakeDistance = 0
                if LastMaxBrake ~= nil then
                    brakeDistance, _ = Kinematic.computeDistanceAndTime(vSpeed, 0, core.getConstructIMass(), 0, 0,
                           LastMaxBrake - (core.g() * core.getConstructIMass())*utils.sign(vSpeedSigned))
                end
                
                
                
                local diff = (Positions[SelectedIndex]-alt)
                diff = diff - utils.sign(diff)*brakeDistance
                distanceToPos = Positions[SelectedIndex]-core.getAltitude()

                local targetSpeed = utils.clamp(diff,-MaxSpeed,MaxSpeed)
                
                -- Figure out how to make this stay over StartPosition in reference to StartVertical
                -- This also needs to apply to longitudinal
                local targetPosition = StartPosition
                
                local vecDiff = targetPosition - vec3(core.getConstructWorldPos())
                local lateralOffset = vecDiff:project_on(constructRight):len() * utils.sign(vecDiff:dot(constructRight))
                
                if (latPID == nil) then
                    latPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                end
                latPID:inject(lateralOffset)
                local finalOffset = latPID:get()
                
                
                --system.print(lateralOffset)
                --local finalOffset = lateralOffset
                --if PrevLatOffset ~= nil then
                --    local mod = (lateralOffset-PrevLatOffset)*CenteringDampening
                --    if mod ~= math.huge and mod ~= -math.huge then
                --        finalOffset = lateralOffset*CenteringForce + mod
                --    end
                --end
                --system.print(finalOffset)
                Nav.axisCommandManager:setThrottleCommand(axisCommandId.lateral, finalOffset*CenteringForce)
                --PrevLatOffset = lateralOffset
                local vecDiffLong = targetPosition - vec3(core.getConstructWorldPos())
                local longitudinalOffset = vecDiffLong:project_on(constructForward):len() * utils.sign(vecDiffLong:dot(constructForward))
                
                if (longPID == nil) then
                    longPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                end
                longPID:inject(longitudinalOffset)
                local finalLongOffset = longPID:get()
                
                --local finalLongOffset = longitudinalOffset
                --if PrevLongOffset ~= nil then
                --    local mod = (longitudinalOffset-PrevLongOffset)*CenteringDampening
                --    if mod ~= math.huge and mod ~= -math.huge then
                --        finalLongOffset = longitudinalOffset*CenteringForce + mod
                --    end
                --end
                --system.print(longitudinalOffset)
                Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, finalLongOffset*CenteringForce)
                PrevLongOffset = longitudinalOffset
                
                
                --if unit.getElementClass() ~= "ECU" then
                    if button_1 and button_1.getState() == 1 then
                        if not ButtonPressed then
                            NextPosition()
                            ButtonPressed = true
                        end
                    elseif button_2 and button_2.getState() == 1 then
                        if not ButtonPressed then
                            PrevPosition()
                            ButtonPressed = true
                        end
                    elseif button_3 and button_3.getState() == 1 then
                        if not ButtonPressed then
                            ExecuteDisplayPosition()
                            ButtonPressed = true
                        end
                    else
                        ButtonPressed = false
                    end
                --end
                local core_altitude = core.getAltitude()
                
                if antigrav and core_altitude > 1000 then
                    LastOn = false -- Force hovers off if we're in antigrav range
                    Nav.axisCommandManager:setTargetGroundAltitude(0)
                    Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                    -- If in antigrav range, we no longer care about speed limits
                    
                    if antigrav.getState() == 0 then
                        antigrav.activate()
                    end
                    
                    -- antigrav by zerofg
                    if core_altitude < 200000 and antigrav.getState() == 1 then
                        if AntigravTargetAltitude == nil then -- no target : try to stabilize if too far from actual altitude
                            local AGGtargetDistance = core_altitude - antigrav.getBaseAltitude()
                            if core_altitude > 800 and AGGtargetDistance < -200 then
                                desiredBaseAltitude = math.max(core_altitude + 100, 1000)
                            elseif AGGtargetDistance > 200 then
                                desiredBaseAltitude = core_altitude - 100
                            end

                        else -- I tried using a PID but didn't work that well, so I'm just regulating speed instead
                            local AGGtargetDistance = AntigravTargetAltitude - core_altitude
                            -- totaly stole the code from lisa-lionheart for vSpeed
                            local velocity = vec3(core.getWorldVelocity())
                            local up = vec3(core.getWorldVertical()) * -1
                            local vSpd = (velocity.x * up.x) + (velocity.y * up.y) + (velocity.z * up.z)

                            -- 290 is about as fast as AGG can go, and is conveniently below the atmos burn speed (1044 km/h)
                            local maxVSpeed = targetSpeed
                            local minVSpeed = -targetSpeed

                            -- when under "strong" planet influence, you can easily get below you AGG base altitude if not carefull
                            if unit.getClosestPlanetInfluence() > 0.3 and minVSpeed < -190 then
                                minVSpeed = -190
                            end

                            -- adjust max speed based on distance, but at least 10m/s
                            minVSpeed = math.min(math.max(minVSpeed, -math.abs(AGGtargetDistance) / 20.0), -10)
                            maxVSpeed = math.max(math.min(maxVSpeed, math.abs(AGGtargetDistance) / 20.0), 10)

                            if vSpd < minVSpeed then -- oh sh*t! oh sh*t! oh sh*t!
                                desiredBaseAltitude = core_altitude + 100

                            elseif vSpd > maxVSpeed then -- not as bad as going too fast down but still need to slow down or at least stop accelerating
                                desiredBaseAltitude = core_altitude - 100

                            elseif math.abs(AGGtargetDistance) > 150 or math.abs(vSpd) > 15 then
                                if math.abs(vSpd) > 10 then
                                    desiredBaseAltitude = core_altitude +
                                                              math.max(math.min(AGGtargetDistance - vSpd / 10.0, 100), -100)
                                else
                                    desiredBaseAltitude = core_altitude + math.max(math.min(AGGtargetDistance, 100), -100)
                                end

                            else -- getting close to the target
                                desiredBaseAltitude = AntigravTargetAltitude
                                finalBrakeInput = 1
                                if math.abs(vSpd) < 10 and math.abs(AGGtargetDistance) < 30 then -- very close and not much speed let's stop there
                                    AntigravTargetAltitude = nil
                                end

                            end
                        end
                    end
                    antigrav.setBaseAltitude(desiredBaseAltitude)
                else
                    
                    local targetSpeedDiff = Positions[SelectedIndex]-core.getAltitude()
                    if ChangingPositions and diff > 1 then
                        targetSpeedDiff = targetSpeed - vSpeedSigned
                    end

                        Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                        local threshold = 0.01
                        --local targetSpeedDiff = Positions[SelectedIndex]-core.getAltitude()
                        --system.print(targetSpeedDiff)
                        if (speedPID == nil) then
                            speedPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        speedPID:inject(targetSpeedDiff)
                        local throt = speedPID:get()
                        --system.print(throt)
                        
                        Nav.axisCommandManager:setThrottleCommand(axisCommandId.vertical, throt*10)
                        if throt <= 0 then
                            finalBrakeInput = 1
                        end
                end
                
                if math.abs(diff) < vSpeed then
                    finalBrakeInput = 1
                end
                
                if brakeDistance > math.abs(Positions[SelectedIndex]-core.getAltitude()) then
                    finalBrakeInput = 1
                    Nav.axisCommandManager:setThrottleCommand(axisCommandId.vertical, -1)
                end
                
                
                if ChangingPositions then
                    --system.print(distanceToPos)
                    if math.abs(distanceToPos) < 0.5 and vSpeed < 0.5 then
                        ChangingPositions = false
                    end
                end


                local autoRollRollThreshold = 0.001
                -- autoRoll
                if currentRollDegAbs > autoRollRollThreshold then
                    local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                    if (rollPID == nil) then
                        rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                    end
                    rollPID:inject(targetRollDeg - currentRollDeg)
                    local autoRollInput = rollPID:get()

                    targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                end
                local autoPitchPitchThreshold = 0.001
                -- autoPitch
                if currentPitchDegAbs > autoPitchPitchThreshold then
                    local targetPitchDeg = utils.clamp(0,currentPitchDegAbs-30, currentPitchDegAbs+30);  -- we go back to 0 within a certain limit
                    if (PitchPID == nil) then
                        PitchPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                    end
                    PitchPID:inject(targetPitchDeg - currentPitchDeg)
                    local autoPitchInput = PitchPID:get()

                    targetAngularVelocity = targetAngularVelocity + autoPitchInput * constructRight
                end
                local autoYawYawThreshold = 0.001
                -- autoYaw
                if currentYawDegAbs > autoYawYawThreshold then
                    local targetYawDeg = utils.clamp(0,currentYawDegAbs-30, currentYawDegAbs+30);  -- we go back to 0 within a certain limit
                    if (YawPID == nil) then
                        YawPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.01) -- magic number tweaked to have a default factor in the 1-10 range
                    end
                    YawPID:inject(targetYawDeg - currentYawDeg)
                    local autoYawInput = YawPID:get()
                    targetAngularVelocity = targetAngularVelocity + autoYawInput * constructUp
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false
                
                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end
                

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: |
                Nav:update()
                content = "<svg width='100%' height='100%' style='position:absolute;top:0;left:0'  viewBox='0 0 1920 1080'>"
                if screen_1 then
                    content = "<svg class='bootstrap' viewBox='0 0 1024 612'>"
                    content = content .. "<path d='M 0 0 L 194 75 Q 512 95 830 75 L 1024 0' style='stroke:black;opacity:1;stroke-width:3;fill-opacity:0.9;fill:rgb(55,55,55)'/>"
                else
                    content = content .. "<path d='M 700 0 L 740 75 Q 960 95 1180 75 L 1220 0' style='stroke:black;opacity:1;stroke-width:3;fill-opacity:0.9;fill:rgb(55,55,55)'/>"
                end
                local font = "Bank"
                if screen_1 then
                    font = "Calibri"
                end
                content = content .. "<text x='50%' y='20px' style='font-size:22px;fill:white;text-anchor:middle;font-family:" .. font .. "'>Atmo Elevator Control</text>"
                local floorString = PositionNames[SelectedIndex]
                local displayString = PositionNames[DisplayIndex]
                if SelectedIndex == 1 then
                    floorString = floorString .. " (Ground)"
                elseif SelectedIndex == #Positions then
                    floorString = floorString .. " (Top)"
                end
                if DisplayIndex == 1 then
                    displayString = displayString .. " (Ground)"
                elseif SelectedIndex == #Positions then
                    displayString = displayString .. " (Top)"
                end
            
                if not ChangingPositions then
                    content = content .. "<text x='50%' y='35px' style='font-size:18px;fill:lightgray;text-anchor:middle;font-family:" .. font .. "'>Current Level: " .. floorString .. "</text>"
                    if button_3 then
                        if DisplayIndex ~= SelectedIndex then
                            content = content .. "<text x='50%' y='48px' style='font-size:18px;fill:KHAKI;text-anchor:middle;font-family:" .. font .. "'>Press To Move To: " .. displayString .. "</text>"
                        else
                            content = content .. "<text x='50%' y='48px' style='font-size:18px;fill:KHAKI;text-anchor:middle;font-family:" .. font .. "'>Use Buttons to Select Floor</text>"
                        end
                    end
                else
                    content = content .. "<text x='50%' y='35px' style='font-size:18px;fill:KHAKI;text-anchor:middle;font-family:" .. font .. "'>Moving To: " .. floorString .. "</text>"
                    content = content .. "<text x='50%' y='48px' style='font-size:16px;fill:orange;text-anchor:middle;font-family:" .. font .. "'>Distance: " .. getDistanceDisplayString(math.abs(distanceToPos)) .. "</text>"
                end
                --if unit.getElementClass() == "ECU" then
                --    content = content .. "<text x='50%' y='60px' style='font-size:18px;fill:darkred;text-anchor:middle;font-family:" .. font .. "'>Activate Controller To Use</text>"
                --else
                    local y = 60
                    if not screen_1 then
                        if button_3 then
                            if DisplayIndex ~= SelectedIndex then
                                if DisplayIndex < #Positions then
                                    content = content .. "<text x='50%' y='" .. y .. "' style='font-size:16px;fill:LAVENDER;text-anchor:middle;font-family:" .. font .. "'>Above - " .. PositionNames[DisplayIndex+1] .. "</text>"
                                    y = y + 15
                                end
                                if DisplayIndex > 1 then
                                    content = content .. "<text x='50%' y='" .. y .. "' style='font-size:16px;fill:LAVENDER;text-anchor:middle;font-family:" .. font .. "'>Below - " .. PositionNames[DisplayIndex-1] .. "</text>"
                                end
                            end
                        else
                            if SelectedIndex < #Positions then
                                content = content .. "<text x='50%' y='" .. y .. "' style='font-size:16px;fill:LAVENDER;text-anchor:middle;font-family:" .. font .. "'>Up - " .. PositionNames[SelectedIndex+1] .. "</text>"
                                y = y + 15
                            end
                            if SelectedIndex > 1 then
                                content = content .. "<text x='50%' y='" .. y .. "' style='font-size:16px;fill:LAVENDER;text-anchor:middle;font-family:" .. font .. "'>Down - " .. PositionNames[SelectedIndex-1] .. "</text>"
                            end
                        end
                    else
                        y = y + 10
                        if SelectedIndex ~= DisplayIndex then
                            content = content .. "<text x='50%' y='" .. y .. "' style='font-size:28px;fill:orange;text-anchor:middle;font-family:" .. font .. "'>Confirm Destination: " .. PositionNames[DisplayIndex] .. "</text>"
                        else
                            content = content .. "<text x='50%' y='" .. y .. "' style='font-size:28px;fill:orange;text-anchor:middle;font-family:" .. font .. "'>Select a Destination</text>"
                        end
                    end
                --end
                if screen_1 then
                    -- Add buttons for the floors
                    local ButtonPadding = 4
                    local ButtonX = ButtonPadding
                    local ButtonY = 105
                    local ButtonWidth = 1024 - ButtonPadding
                    local ButtonHeight = 35
                    local defaultFill = "rgb(39,89,87)"
                    local selectedFill = "rgb(200,200,200)"
                    local defaultFontColor = "white"
                    local selectedFontColor = "black"
                    local displayFill = "orange"
                    
                    for k,v in pairs(Positions) do
                        local buttonX = ButtonX
                        local buttonY = ButtonY + (#Positions-k)*(ButtonHeight+ButtonPadding)
                        
                        local selected = (k == SelectedIndex)
                        local selectedDisplay = (k == DisplayIndex)

                        -- Draw a rectangle for the 'button'
                        content = content .. '<rect width="' .. ButtonWidth .. '" height="' .. ButtonHeight .. '" x="' .. buttonX .. '" y="' .. buttonY .. '" style="fill:'
                        if selected then
                            content = content .. selectedFill
                        elseif selectedDisplay then
                            content = content .. displayFill
                        else
                            content = content.. defaultFill
                        end
                        content = content .. ';stroke-width:1;stroke:white;" />'
                        -- And draw the text
                        content = content .. "<text x='" .. buttonX + ButtonWidth/2 .. "' y='" .. buttonY + ButtonHeight/2 + 4 .. "' font-size='24px' fill='"
                        if selected or selectedDisplay then
                            content = content .. selectedFontColor
                        else
                            content = content.. defaultFontColor
                        end 
                        content = content .. "' text-anchor='middle' font-family='" .. font .. "'>" .. PositionNames[k] .. "</text>"
                    end
                end
                content = content .. "</svg>"
                if not screen_1 then
                    system.showScreen(1)
                    system.setScreen(content)
                else
                    screen_1.setHTML(content)
                end
        actionStart:
            args: [up]
            lua: |
                NextPosition()
                
        actionStart:
            args: [down]
            lua: |
                PrevPosition()
        
